\mtcaddchapter
\chapter{Constructs for Infinite Scale: the `root' keyword}
\minitoc

Modern software systems face an unprecedented challenge: they must work equally well for a single user testing locally and for millions of users distributed across the globe. Yet most programming languages force developers to make fundamental architectural decisions early in development—choices about persistence, user isolation, and entry points that become increasingly difficult to change as applications scale. This architectural rigidity creates a painful discontinuity in the development process, where applications that work perfectly at small scale require complete rewrites when they need to serve thousands or millions of users.

Jac addresses this challenge through what we call \textbf{scale-agnostic programming}—a set of language constructs that enable applications to naturally adapt to different execution scales without explicit modification. At the heart of this approach is the \texttt{root} keyword, a deceptively simple construct that fundamentally changes how we think about application state, user contexts, and program execution models.

The power of scale-agnostic programming becomes apparent when you consider the typical evolution of a software project. You start with a simple script or prototype, then add user authentication, then persistence, then multi-tenancy, then distribution across multiple servers. Each of these transitions traditionally requires significant architectural changes, often forcing you to rewrite substantial portions of your application. With Jac's scale constructs, the same code that works for your initial prototype continues to work as your application grows, with the runtime system automatically handling the complexity of scale.

This chapter explores how Jac's scale constructs—centered around the \texttt{root} keyword—enable this seamless scaling. You'll learn how the root node provides a persistent anchor for your application's state, how user isolation happens automatically, and how walkers can serve as entry points for building service-oriented architectures. By the end, you'll understand how to write applications that are inherently prepared for any scale, from prototype to global platform.

\section{The Root Node: A Persistent Anchor in Topological Space}

The \texttt{root} keyword represents one of Jac's most powerful abstractions: a globally accessible node that serves as a persistent anchor for your application's topological space. Unlike regular nodes that exist only during program execution, the root node and everything connected to it automatically persists across program runs, creating a natural boundary between ephemeral computation and persistent state.

To understand the significance of this design, consider how traditional applications handle persistence. You typically need to explicitly save and load data, manage database connections, handle serialization, and ensure consistency between your in-memory representation and persistent storage. The root node eliminates this complexity by making persistence a property of connectivity rather than explicit operations.

\subsection{Global Accessibility and Automatic Persistence}

The root node is accessible from anywhere in your program through the \texttt{root} keyword, similar to how \texttt{self} provides access to the current object or \texttt{here} provides access to the current object-spatial location. This global accessibility, combined with automatic persistence, creates a programming model where state management becomes remarkably simple.

\begin{jacblock}
node Profile {
    has username: str = "";
    has created_at: str = "";

    can update with update_profile entry {
        self.username = visitor.new_username;
        report self;
    }
}

walker create_user_profile {
    has username: str;

    can create with `root entry {
        # Check if profile already exists
        existing_profile = [root-->(`?Profile)];
        if existing_profile {
            report existing_profile[0];
        } else {
            # Create new profile connected to root
            new_profile = root ++> Profile(username=self.username);
            report new_profile[0];
        }
    }
}
\end{jacblock}

In this example, the profile node becomes persistent simply by being connected to the root node through the \texttt{++>} operator. There's no explicit save operation, no database schema to manage, and no serialization code to write. The connection to root is all that's needed to ensure the profile persists across program executions.

This persistence-by-reachability model creates an intuitive mental model: if something is connected to your application's root, it persists. If it becomes disconnected, it can be garbage collected. This approach eliminates entire classes of persistence-related bugs while making the persistence boundaries of your application explicit in the code structure itself.

\subsection{Topological Persistence}

The root node acts as an anchor for a subgraph of your program's overall topology. Any node reachable from the root node through a path of edges becomes part of this persistent subgraph and is automatically preserved between program executions. This creates a natural way to model complex, interconnected persistent state without the impedance mismatch typically associated with object-relational mapping.

Consider a social media application where users can follow each other, create posts, and form groups. In traditional architectures, you'd need separate tables for users, posts, follows, group memberships, and their relationships. With Jac's topological persistence, these relationships are expressed directly in the graph structure:

\begin{jacblock}
node Profile {
    has username: str;
    has bio: str = "";

    can follow with follow_request entry {
        target_profile = [root-->(`?Profile) where (_.username == visitor.target_username)];
        if target_profile {
            self +>:Follow():+> target_profile[0];
            report {"status": "followed", "user": target_profile[0].username};
        }
    }
}

node Tweet {
    has content: str;
    has created_at: str;

    can like_tweet with like_tweet entry {
        current_profile = [root-->(`?Profile)];
        self +>:Like():+> current_profile[0];
        report self;
    }
}

edge Follow {
    has followed_at: str = datetime.datetime.now().isoformat();
}

edge Post {
    has posted_at: str = datetime.datetime.now().isoformat();
}

edge Like {
    has liked_at: str = datetime.datetime.now().isoformat();
}
\end{jacblock}

The relationships between users (follows), between users and their posts, and between users and liked tweets are all expressed as edges in the graph. Because all these nodes are reachable from user profiles connected to root, the entire social graph persists automatically. Complex queries like "find all posts from users I follow" become simple graph traversals, and the persistence layer handles the complexity of storing and retrieving this interconnected data.

\subsection{Multi-User Context Through Root Isolation}

One of the most elegant aspects of the root node design is how it naturally handles multi-user contexts. Each user interacting with your application has their own distinct root node, creating automatic isolation between user contexts without requiring explicit session management or tenant isolation logic.

This per-user root isolation means that when a user's walker accesses \texttt{root}, they're accessing their personal persistent subgraph, not a shared global state. This design eliminates entire categories of security vulnerabilities and data leakage issues that plague traditional multi-tenant applications.

\begin{jacblock}
walker visit_profile {
    can visit_profile with `root entry {
        # This finds the current user's profile, not any profile
        visit [-->(`?Profile)] else {
            # Create profile for this specific user
            new_profile = here ++> Profile();
            visit new_profile;
        }
    }
}

walker load_user_feed {
    has results: list = [];

    can load with Profile entry {
        # Load tweets from users this specific user follows
        for followed_user in [->:Follow:->(`?Profile)] {
            for tweet in [followed_user-->(`?Tweet)] {
                self.results.append(tweet.get_info());
            }
        }
    }
}
\end{jacblock}

The beauty of this approach is that the same code works whether you're building a single-user desktop application or a multi-million-user web service. The runtime system handles the complexity of user identification, session management, and data isolation, while your application code remains focused on business logic.

\section{Walkers as Entry Points: From Traversals to APIs}

Traditional programming languages assume a single entry point—typically a \texttt{main()} function—where program execution begins. This model works well for batch processing and command-line tools but poorly represents modern applications that are fundamentally service-oriented, with multiple entry points corresponding to different user actions or external events.

Jac's walker system naturally extends to support multiple entry points through walker entry point designation. Any walker can be marked as an entry point, automatically generating appropriate interfaces for external invocation while maintaining the object-spatial programming model internally.

\subsection{Entry Point Registration and Parameter Mapping}

Walkers become entry points simply by being designated as such, typically through configuration or runtime registration. When a walker is designated as an entry point, the Jac runtime automatically generates appropriate interfaces—REST API endpoints, GraphQL resolvers, event handlers, or command-line interfaces—based on the walker's signature and behavior.

\begin{jacblock}
walker update_profile(visit_profile) {
    has new_username: str;

    # This walker automatically becomes available as an API endpoint
    # POST /update_profile with {"new_username": "john_doe"}
}

walker create_tweet(visit_profile) {
    has content: str;

    can tweet with Profile entry {
        embedding = vectorizer.fit_transform([self.content]).toarray().tolist();
        tweet_node = here +>:Post():+> Tweet(
            content=self.content,
            embedding=embedding
        );
        report tweet_node[0];
    }

    # This walker becomes available as:
    # POST /create_tweet with {"content": "Hello, world!"}
}

walker load_feed(visit_profile) {
    has search_query: str = "";
    has results: list = [];

    can load with Profile entry {
        # Load tweets from followed users
        for user_node in [->:Follow:->(`?Profile)] {
            visit [user_node-->(`?Tweet)];
        }
    }

    can search_tweet with Tweet entry {
        if self.search_query {
            similarity = search_tweets(self.search_query, here.content);
            self.results.append({
                "tweet": here.get_info(),
                "similarity": similarity
            });
        } else {
            self.results.append(here.get_info());
        }
    }

    can report_feed with exit {
        self.results.sort(key=lambda x: x.get('similarity', 0), reverse=True);
        report self.results;
    }

    # This walker becomes available as:
    # GET /load_feed?search_query=python
}
\end{jacblock}

The runtime system handles the mechanical details of parameter validation, authentication, response formatting, and error handling. Your walker code focuses purely on the business logic of traversing the user's graph and collecting relevant information.

\subsection{Execution Context Management}

When a walker entry point is invoked externally, the runtime system automatically establishes the appropriate execution context. This includes identifying the user (through authentication tokens, session cookies, or other mechanisms), locating their root node, and setting up proper isolation boundaries.

This automatic context management is crucial for building secure, multi-tenant applications. The same walker code that works for a single user automatically works for millions of users, with the runtime ensuring that each invocation operates within the correct user context.

\begin{jacblock}
walker load_user_profiles {
    # This walker has special permissions to see across user boundaries
    obj __specs__ {
        static has auth: bool = False;  # No authentication required
    }

    can load_profiles with `root entry {
        self.profiles: list = [];

        # allroots() provides access to all user root nodes
        # (requires special permissions)
        for each_root in allroots() {
            profile = [each_root-->(`?Profile)][0];
            self.profiles.append({
                "name": profile.username,
                "id": jid(profile)
            });
        }
    }

    can report_profiles with exit {
        report self.profiles;
    }
}
\end{jacblock}

The \texttt{allroots()} function demonstrates how Jac can provide controlled access to cross-user data when needed (for administrative functions, analytics, etc.) while maintaining the default isolation model for regular application code.

\section{Scale-Agnostic Programming in Practice}

The combination of persistent root nodes and walker entry points creates a programming model that naturally adapts to different scales without requiring architectural changes. To understand how this works in practice, let's examine how the same Jac code behaves at different scales.

\subsection{Development Scale: Single User, Local Execution}

During development, your Jac application runs locally with a single user context. The root node persists to local storage, walker entry points are accessible through a development server or command-line interface, and the entire application state fits in memory.

\begin{jacblock}
# Development: jac run social_app.jac
# - Single root node persisted locally
# - Walker entry points available at http://localhost:8000
# - All data in local files or embedded database

walker create_tweet(visit_profile) {
    has content: str;

    can tweet with Profile entry {
        # Same code works for development and production
        tweet_node = here +>:Post():+> Tweet(content=self.content);
        report tweet_node[0];
    }
}
\end{jacblock}

\subsection{Production Scale: Multi-User, Distributed Execution}

In production, the same code automatically adapts to serve multiple users with proper isolation. The runtime system handles user authentication, distributes root nodes across database shards, implements caching strategies, and scales walker execution across multiple servers.

\begin{jacblock}
# Production: same code, different runtime configuration
# - Multiple root nodes, one per user
# - Walker entry points become REST API endpoints
# - Data distributed across database clusters
# - Automatic scaling based on load

# The walker code remains identical:
walker create_tweet(visit_profile) {
    has content: str;

    can tweet with Profile entry {
        # Runtime handles:
        # - User identification and authentication
        # - Loading user's root node from distributed storage
        # - Ensuring isolation from other users
        # - Persisting changes back to storage
        tweet_node = here +>:Post():+> Tweet(content=self.content);
        report tweet_node[0];
    }
}
\end{jacblock}

\subsection{Global Scale: Geographic Distribution}

At global scale, the runtime can distribute user root nodes geographically, placing data close to users for optimal performance. Walker executions can be routed to the appropriate geographic region automatically, while maintaining consistency across the global system.

The key insight is that your application code doesn't change—the scale-agnostic constructs provide enough semantic information for the runtime to make appropriate scaling decisions automatically.

\section{Advanced Patterns with Scale Constructs}

The root keyword and walker entry points enable sophisticated architectural patterns that would be difficult or impossible to express cleanly in traditional languages. These patterns leverage the topological nature of Jac's programming model to create naturally distributed, resilient systems.

\subsection{Cross-User Interactions}

While users are typically isolated through separate root nodes, controlled cross-user interactions are essential for social applications, collaborative systems, and marketplace platforms. Jac provides mechanisms for safe cross-user operations while maintaining security and isolation guarantees.

\begin{jacblock}
walker send_message {
    has recipient_username: str;
    has message_content: str;

    can send with Profile entry {
        # Find recipient across all users (requires permission)
        recipient = find_user_by_username(self.recipient_username);
        if recipient {
            # Create message in sender's space
            message = here +>:Sent():+> Message(
                content=self.message_content,
                recipient=self.recipient_username
            );

            # Notify recipient's space (cross-user operation)
            recipient_root = get_user_root(self.recipient_username);
            recipient_profile = [recipient_root-->(`?Profile)][0];
            message +>:Received():+> recipient_profile;

            report {"status": "sent", "message_id": jid(message)};
        }
    }
}
\end{jacblock}

\subsection{Distributed Computation Patterns}

Walker entry points can coordinate distributed computations across multiple user contexts or system boundaries. This enables patterns like map-reduce operations, distributed consensus, and cross-shard transactions while maintaining the object-spatial programming model.

\begin{jacblock}
walker compute_network_metrics {
    has metric_type: str;
    has results: dict = {};

    can compute with `root entry {
        # Coordinate computation across all user graphs
        for user_root in allroots() {
            user_metrics = self.compute_user_metrics(user_root);
            self.results[str(user_root)] = user_metrics;
        }
    }

    def compute_user_metrics(user_root) -> dict {
        profile = [user_root-->(`?Profile)][0];

        if self.metric_type == "influence" {
            # Calculate user influence based on network topology
            followers = len([profile<-:Follow:<-]);
            following = len([profile->:Follow:->]);
            posts = len([profile-->(`?Tweet)]);

            return {
                "followers": followers,
                "following": following,
                "posts": posts,
                "influence_score": followers * 0.6 + posts * 0.4
            };
        }

        return {};
    }
}
\end{jacblock}

\subsection{Event-Driven Architectures}

Walker entry points naturally support event-driven patterns, where external events trigger walker executions that propagate through the user's graph topology. This enables reactive systems that respond to changes in real-time while maintaining consistency.

\begin{jacblock}
walker handle_user_action {
    has action_type: str;
    has action_data: dict;

    can process with Profile entry {
        match self.action_type {
            case "post_liked" {
                # Propagate like notification
                post_id = self.action_data["post_id"];
                post = get_node_by_id(post_id);
                author = [post<-:Post:<-][0];

                # Create notification in author's space
                notification = author +>:Notified():+> Notification(
                    type="like",
                    from_user=here.username,
                    content=f"{here.username} liked your post"
                );
            }

            case "user_followed" {
                # Update recommendation algorithms
                self.update_user_recommendations();
            }
        }
    }
}
\end{jacblock}

\section{Performance and Optimization Considerations}

Scale-agnostic programming doesn't mean ignoring performance—it means providing the runtime system with enough semantic information to make optimal scaling decisions automatically. Jac's scale constructs enable sophisticated optimizations that would be difficult to implement manually.

\subsection{Automatic Caching and Preloading}

The runtime system can analyze graph access patterns and automatically implement caching strategies, preloading frequently accessed nodes and edges to minimize latency. Because the topological relationships are explicit in the code, the runtime can make intelligent decisions about what to cache and when.

\subsection{Distributed Execution Optimization}

Walker traversals can be automatically distributed across multiple servers based on the topology of the data they're accessing. If a walker needs to traverse a large subgraph, the runtime can partition the traversal across multiple machines and aggregate the results.

\subsection{Storage Optimization}

The persistence-by-reachability model enables sophisticated storage optimizations. Frequently accessed subgraphs can be kept in fast storage, while rarely accessed data can be moved to cheaper, slower storage. The runtime can make these decisions based on actual usage patterns rather than manual configuration.

\section{Migration Strategies and Best Practices}

Adopting scale-agnostic programming requires understanding how to migrate existing applications and design new ones to take full advantage of Jac's scale constructs. This section provides practical guidance for both scenarios.

\subsection{Migrating Existing Applications}

When migrating an existing application to use Jac's scale constructs, start by identifying the core entities and relationships in your current system. These typically map naturally to nodes and edges in the Jac model.

\begin{jacblock}
# Before: Traditional database-backed user system
class User:
    def __init__(self, username):
        self.username = username
        self.id = generate_user_id()
        save_to_database(self)

    def follow(self, other_user):
        create_follow_relationship(self.id, other_user.id)

# After: Jac scale-agnostic version
node Profile {
    has username: str;

    can follow with follow_request entry {
        target = find_profile_by_username(visitor.target_username);
        if target {
            self +>:Follow():+> target;
            report {"status": "followed"};
        }
    }
}
\end{jacblock}

The migration typically involves:
1. Converting database tables to node types
2. Converting foreign key relationships to edges
3. Converting API endpoints to walker entry points
4. Connecting core entities to the root node for persistence

\subsection{Designing Scale-Agnostic Applications}

When designing new applications with scale-agnostic principles, think in terms of user-centric topologies rather than global data models. Each user should have their own subgraph connected to their root node, with controlled mechanisms for cross-user interactions.

\begin{jacblock}
# Design pattern: User-centric topology
node UserRoot {
    # Each user's personal space
}

node Profile {
    # User's identity and preferences
}

node Document {
    # User's private documents
}

node SharedSpace {
    # Controlled sharing between users
    has permissions: dict;
}

edge Owns {}
edge Collaborates {}
edge Shares {}
\end{jacblock}
