\mtcaddchapter
\chapter{Jac Supersets Python Natively}
\minitoc

At its core, Jac represents a natural evolution of Python—not a replacement, but an enhancement. For Python developers accustomed to the language's expressiveness and ecosystem, Jac offers a familiar foundation with powerful extensions for modern software architecture. This chapter explores how Jac achieves this delicate balance: preserving everything that makes Python productive while introducing higher-level abstractions that address common architectural patterns and complexity management challenges that Python developers face in large-scale systems.

The relationship between Jac and Python is fundamentally different from typical language interoperability stories. Rather than building bridges between separate runtime environments or maintaining foreign function interfaces, Jac operates as a true superset that compiles down to native Python. This design philosophy ensures that your existing Python knowledge, tools, and libraries remain directly applicable while gaining access to Jac's advanced features for object-spatial programming, architectural patterns, and semantic clarity.

\section{Jac is Transpiled (...and compiled)}

Understanding Jac's compilation model is incredibly helpful for leveraging its full potential. When we say Jac is a superset of Python, we mean something specific and powerful: Jac's grammar strictly extends Python's grammar, adding higher-level constructs and object–spatial features while preserving Python's semantics. This relationship differs from a simple syntactic extension—``superset'' here does not mean every valid Python source file is also a valid Jac source file. Instead, it means Jac provides the full expressivity of Python and then adds more. You can express any Python program logic in Jac, enhanced with idiomatic Jac features, and the resulting program behaves as a native Python program at runtime.

The architectural choice to build Jac as a transpiled language brings significant advantages. Unlike languages that require their own runtime environments, virtual machines, or interpreters, Jac programs execute on the standard Python runtime. This means you inherit Python's mature ecosystem: its garbage collector, memory management, threading model, and crucially, its vast library ecosystem. Every Python package on PyPI, every internal library your team has built, every deployment tool and monitoring solution you use—they all work seamlessly with Jac code.

Conceptually, Jac plays a similar role to how TypeScript or CoffeeScript relates to JavaScript: as TypeScript or CoffeeScript is JavaScript with wings, Jac is Python with wings. However, Jac goes beyond simple syntactic sugar. It introduces semantic constructs that fundamentally change how you think about program organization and data flow, while ensuring these constructs compile down to efficient Python implementations.

\begin{figure}[t]
    \centering
    \begin{tikzpicture}[node distance=10mm and 12mm, >=Latex, font=\footnotesize]
        % styles
        \tikzstyle{proc}=[rectangle, rounded corners=2pt, draw=black, fill=blue!6, minimum width=28mm, minimum height=8mm, align=center]
        \tikzstyle{data}=[rectangle, draw=black, fill=green!6, minimum width=28mm, minimum height=8mm, align=center]

        % nodes
        \node[data] (psrc) {Python Source};
        \node[proc, below=of psrc] (past) {Parse to\\Python AST};
        \node[proc, right=of psrc] (pbyte) {CPython compiler\\to bytecode};
        \node[data, below=of pbyte] (pexec) {Execute};

        % edges
        \draw[->] (psrc) -- (past);
        \draw[->] (past) -- (pbyte);
        \draw[->] (pbyte) -- (pexec);
    \end{tikzpicture}
    \caption[]{Baseline Python pipeline: source \(\to\) AST \(\to\) CPython bytecode \(\to\) execute.}
    \label{fig:py-pipeline}
\end{figure}

To appreciate how Jac integrates with Python, let's first review Python's own compilation model, illustrated in Figure~\ref{fig:py-pipeline}. At runtime, Python compiles \emph{module by module}. When you import a module, Python parses its source into an Abstract Syntax Tree (AST), compiles this AST to a code object containing bytecode instructions, then executes the module body once. The interpreter caches the resulting bytecode under \texttt{\_\_pycache\_\_} for faster subsequent imports, recompiling only when the source file changes. Executing a script follows the same process for the entry module. Function and class bodies are compiled when their definitions are encountered during module execution; their code objects become attributes of the module namespace. The unit of compilation and execution is thus the Python module—a design that provides predictable import semantics and enables incremental development.

This module-centric compilation model has profound implications for how Python programs are structured and executed. Each module maintains its own namespace, imports create references between these namespaces, and the execution order follows the dependency graph of imports. Python developers intuitively understand these semantics: they know that module-level code runs once at import time, that circular imports can cause problems if not carefully managed, and that changes to mutable module-level state persist across the program's lifetime.

\begin{figure}[t]
    \centering
    \begin{tikzpicture}[node distance=10mm and 12mm, >=Latex, font=\footnotesize]
        % styles
        \tikzstyle{proc}=[rectangle, rounded corners=2pt, draw=black, fill=blue!6, minimum width=28mm, minimum height=8mm, align=center]
        \tikzstyle{data}=[rectangle, draw=black, fill=green!6, minimum width=28mm, minimum height=8mm, align=center]
        \tikzstyle{note}=[rectangle, draw=black, fill=orange!10, minimum width=30mm, minimum height=8mm, align=center]

        % nodes
        \node[data] (src) {Jac Source};
        \node[proc, below=of src] (jacast) {Parse to\\Jac AST};
        \node[note, below=of jacast] (pre) {Jac high level\\analysis and\\optimizations (optional)};
        \node[proc, right=of jacast] (pyast) {Transpile to\\Python AST\\(+ runtime hooks)};
        \node[data, below=of pyast, draw, dotted] (pyprint) {Generate Python\\Source Code (optional)};
        \node[proc, above=of pyast] (bytecode) {CPython compiler\\to bytecode};
        \node[note, right=of bytecode] (post) {Jac level\\analysis and\\optimization (optional)};
        \node[data, below=of post] (out) {Execute / Package};

        % edges
        \draw[->] (src) -- (jacast);
        \draw[->] (jacast) -- (pre);
        \draw[->] (pre) -- (pyast);
        \draw[->] (pyast) -- (bytecode);
        \draw[->, dashed] (pyast) -- (pyprint);
        \draw[->] (bytecode) -- (post);
        \draw[->] (post) -- (out);
    \end{tikzpicture}
    \caption[]{Compilation pipeline from Jac to native Python execution.}
    \label{fig:jac-pipeline}
\end{figure}

Jac's compilation pipeline, shown in Figure~\ref{fig:jac-pipeline}, elegantly extends Python's model while preserving its semantics. The pipeline operates through several well-defined stages, each serving a specific purpose in the translation from high-level Jac constructs to executable Python bytecode. As shown in the figure, under the hood, the compilation pipeline works like this:

\begin{itemize}
    \item Jac source is parsed into a Jac-specific AST.
    \item Optional high-level analysis and optimization passes run over the Jac AST.
    \item The Jac AST is mechanically transpiled into a pure Python AST, with well-defined callbacks into the Jac runtime for Jac-only semantics.
    \item Optional code generation is performed to produce Python source code.
    \item The Python AST is compiled to CPython bytecode using Python's internal compiler pipeline.
    \item Optional low-level analysis/optimization and metadata attachment are applied to the resulting bytecode/module artifacts.
    \item The resulting artifact is executed directly or packaged like ordinary Python code.
\end{itemize}

Each stage in this pipeline serves a deliberate purpose. The Jac-specific AST stage allows the language to implement its own syntax and semantic rules without being constrained by Python's parser. The optional optimization passes can perform Jac-aware transformations that would be impossible at the Python level—for instance, optimizing walker traversal patterns or pre-computing node connectivity metadata. The transpilation to Python AST is where the magic happens: Jac's high-level constructs are systematically transformed into equivalent Python code, with calls to a lightweight runtime library handling Jac-specific semantics like object-spatial operations and architectural patterns.

The optional Python source generation capability deserves special attention. While Jac code can execute directly through the compilation pipeline, the ability to emit readable Python source provides tremendous value for debugging, integration with existing tools, and building trust with teams adopting Jac incrementally. You can inspect exactly what your Jac code becomes, understand the performance characteristics, and even check the generated Python into version control if needed for deployment scenarios where Jac isn't available.

Jac mirrors Python's module-by-module behavior with remarkable fidelity. When you import a Jac module or run a Jac program, the Jac importer intercepts the import request and transpiles that single \texttt{.jac} module to a Python AST on demand. It then compiles this AST using the standard CPython compiler, executes the resulting module body once, and exposes regular Python module objects to the rest of your program. Downstream imports repeat this per-module process. The option to emit pure Python sources or cache intermediate artifacts makes subsequent runs as fast and predictable as native Python, eliminating any runtime overhead from the transpilation process.

This module-by-module approach has several advantages. First, it maintains Python's lazy loading semantics—modules are only compiled when actually imported, reducing startup time for large applications. Second, it enables incremental adoption—you can convert modules to Jac one at a time without affecting the rest of your codebase. Third, it preserves Python's development workflow—you can modify a Jac file and see the changes on the next run, just like with Python.

The consequence is powerful: you can reason about Jac as a natively Pythonic language. You get Python's ecosystem, tooling, and predictable runtime model, while writing in a language that raises the level of abstraction for architecture, dataflow, and object–spatial programming. Your IDE's Python debugger works with Jac code. Your unit test framework runs Jac tests. Your deployment pipeline handles Jac applications. This isn't just interoperability—it's genuine unity at the execution level.

Here's a tiny Jac example that demonstrates the key language constructs:

\begin{jacblock}
def foo() -> str {
    return "Hello";
}

obj vehicle {
    has name: str = "Car";
}

enum Size {
    Small=1, Medium=2, Large=3
}

with entry {
    car = vehicle();
    print(foo());
    print(car.name);
    print(Size.Medium.value);
}
\end{jacblock}

This example showcases several Jac features: function definitions with brace-delimited blocks, object archetypes with the \texttt{obj} keyword, enumerations with explicit values, and the \texttt{with entry} construct for module entry points. Each of these constructs has clear semantics that map to Python equivalents while providing more expressive syntax and clearer intent.

The Jac compiler will transpile this into a pure Python module with calls into the Jac runtime for Jac-specific semantics. While the actual generated code includes additional machinery for Jac's features, a very rough Python shape might look like the following (greatly simplified for readability):

\begin{lstlisting}[language=Python]
from enum import Enum

def foo() -> str:
    return "Hello"

class vehicle:
    def __init__(self) -> None:
        self.name: str = "Car"

class Size(Enum):
    Small = 1; Medium = 2; Large = 3

if __name__ == "__main__":
    car = vehicle()
    print(foo())
    print(car.name)
    print(Size.Medium.value)
\end{lstlisting}

This simplified view helps illustrate the fundamental principle: Jac code becomes Python code. The actual transformation is more sophisticated, handling Jac's advanced features like walker protocols, node connections, and ability decorators, but the essence remains—every Jac construct has a well-defined Python representation.

\begin{nerd}
\textbf{Under the hood}\quad Jac's transpiler maintains a one-to-one mapping from Jac AST nodes to Python AST nodes wherever possible. Where Jac introduces new semantics, the transpiler emits calls into a compact Jac execution library. The Python AST is compiled using the same CPython compiler that compiles ordinary Python, yielding standard bytecode that the Python VM executes. Because the compiler still holds references to that bytecode, it can attach metadata (for tooling, debugging, or optimization) before handing off to the runtime. This architecture is why Jac feels native in Python ecosystems.
\end{nerd}

The transpiler's design philosophy emphasizes predictability and debuggability. When you write a Jac function, it becomes a Python function. When you define a Jac object, it becomes a Python class. This direct mapping means that Python's introspection capabilities work naturally with Jac code—you can use \texttt{dir()}, \texttt{help()}, \texttt{inspect}, and other familiar tools to explore Jac modules and their contents. Error messages and stack traces reference your original Jac source locations, maintaining the debugging experience you expect.

\section{Jac and Python are Friends (no need to choose)}

The relationship between Jac and Python transcends typical language interoperability. Rather than viewing them as separate languages that need to communicate, think of Jac as Python with enhanced expressive power. This fundamental unity manifests in practical ways that eliminate the friction typically associated with polyglot development.

Jac and Python interoperate seamlessly because they share the same runtime, object model, and execution semantics. Unlike languages that bolt on a foreign function interface or require complex marshaling between different memory representations, Jac is natively Python: the output is pure Python modules with a thin, principled runtime library written in pure Python. This runtime library doesn't introduce a new virtual machine or execution model—it simply provides a small set of primitives needed to realize Jac-specific semantics like object-spatial operations and walker protocols.

This deep integration means:

\begin{itemize}
    \item You can import Jac modules from Python with familiar syntax. (thanks to PEP 302)
    \item You can import Python modules from Jac with familiar syntax.
    \item You can embed native Python blocks directly inside Jac files for specialized needs.
    \item You can emit pure Python from any Jac program and import it from Python code without glue.
    \item Library elements that the Jac transpiler would generate (e.g., decorators and helper classes) are regular Python artifacts you can use directly in any Python code. (That is if for some reason you wanted to avoid using Jac's language syntax but still wanted to use Jac's semantics as a python library.)
\end{itemize}

Each of these capabilities opens up different integration strategies. You might start by writing new modules in Jac while keeping your existing Python codebase intact. Or you might identify architectural components that would benefit from Jac's abstractions and gradually migrate them. You could even use Jac as a design language, prototyping architectures in Jac and then generating Python for production deployment. The choice is yours, and you can change strategies as your needs evolve.

\subsection{Jac in your Python Codebase}

Integrating Jac modules into existing Python projects requires minimal setup. The key insight is that Jac modules become Python modules at runtime, making them indistinguishable from native Python code to the rest of your application. This seamless integration is possible because Jac leverages Python's import hook mechanism (PEP 302) to intercept import statements and transparently compile Jac source files.

Jac modules are importable from Python like regular modules. When you import \texttt{jaclang}, it installs a meta importer so that \texttt{.jac} files can be loaded natively by Python's import system. This meta importer integrates with Python's import machinery at a fundamental level, ensuring that all import-related features work as expected: relative imports, package structures, namespace packages, and even import-time side effects.

\subsubsection{Native import (recommended)}

The simplest and most Pythonic approach uses standard import statements after enabling Jac support:

\begin{lstlisting}[language=Python]
import jaclang  # enable .jac imports

# If your project has a package "app/" with a Jac module app/logic.jac
import app.logic  # loads app/logic.jac

# Use exported classes/functions from the Jac module as usual
print(app.logic.__name__)
\end{lstlisting}

This approach requires no changes to your existing import statements or project structure. Once \texttt{jaclang} is imported, the Python interpreter treats \texttt{.jac} files as first-class modules. Your IDE's autocomplete, type checking, and refactoring tools continue to work, though they may need plugins to fully understand Jac syntax within \texttt{.jac} files.

\begin{nerd}
\textbf{How native \texttt{.jac} import works (PEP 302)}\quad This feature takes advantage of Python's elegant, extensible import machinery that is realized through PEP 302's import hook model. Importing \texttt{jaclang} registers a meta path finder on \texttt{sys.meta\_path} that recognizes modules resolving to \texttt{.jac} sources and provides a \texttt{ModuleSpec} with a custom loader. That loader resolves the \texttt{.jac} file using Python's normal package rules, parses it to a Jac AST, transpiles to a Python \texttt{ast.AST}, compiles the AST to a code object via the CPython compiler, creates a module object while setting \texttt{\_\_file\_\_}, \texttt{\_\_package\_\_}, \texttt{\_\_loader\_\_}, and \texttt{\_\_spec\_\_}, executes the code object in the module's namespace, and installs the module into \texttt{sys.modules}. This adheres to PEP 302's import hook model and PEP 451's \texttt{ModuleSpec} refinement, so relative imports, packages and namespace packages, caching in \texttt{\_\_pycache\_\_/}, and reload semantics behave exactly like any Python module; caches are invalidated when the \texttt{.jac} source changes, and if a request isn't for \texttt{.jac} the finder simply defers to the rest of \texttt{sys.meta\_path}.
\end{nerd}

\subsubsection{Programmatic import (explicit control)}

For scenarios requiring finer control over the import process—such as dynamically loading modules, handling multiple versions, or implementing custom resolution logic—use the Jac API:

\begin{lstlisting}[language=Python]
from jaclang import JacMachine as Jac

# Import a Jac module by name relative to a base path (dir or __file__)
(mod,) = Jac.jac_import(target="hello_world", base_path=__file__)

# Work with exported archetypes (nodes, edges, walkers) and functions
print(dir(mod))
\end{lstlisting}

This programmatic approach provides additional capabilities beyond standard imports. You can specify custom search paths, control compilation options, and even modify the transpilation process for specific modules. This level of control proves valuable in complex deployment scenarios or when building development tools that work with Jac code.

Notes:
\begin{itemize}
    \item \texttt{target} is the module name without \texttt{.jac}; \texttt{base\_path} is a directory or file path used to resolve relative imports.
    \item You can also import specific items with Python imports from Jac packages, e.g., \texttt{from mypkg.mymod import MyWalker} once the meta importer is active.
\end{itemize}

The import system also handles edge cases gracefully. If a Jac module has compilation errors, you get standard Python \texttt{SyntaxError} exceptions with proper line numbers. If a Jac module depends on Python packages that aren't installed, you get normal \texttt{ImportError} exceptions. This consistency means your existing error handling and logging infrastructure works without modification.

\subsection{Python in your Jac Codebase}

From Jac's perspective, Python modules are just modules. The import syntax in Jac intentionally mirrors Python's with minor enhancements for clarity and convenience. This symmetry means Python developers can immediately understand and write import statements in Jac without learning new concepts.

Import Python packages and symbols directly from Jac using familiar syntax. Non-\texttt{.jac} imports are forwarded to Python's importer, ensuring that all Python packages—whether from the standard library, third-party packages from PyPI, or your own internal modules—work identically in Jac code.

\begin{jacblock}
// whole-module and aliased imports
import math;
import datetime as dt;

// selective imports with braces
import from typing { Optional, Tuple };
import from math { sqrt as square_root };

// include-style import (bring public names into scope)
include os.path;

with entry {
    x = square_root(16);
    print(dt.datetime.now());
}
\end{jacblock}

The brace syntax for selective imports provides a cleaner alternative to Python's comma-separated imports, especially when importing multiple symbols. The \texttt{include} statement offers functionality similar to Python's \texttt{from module import *} but with better semantics and tooling support. These syntactic improvements maintain full compatibility with Python's import semantics while providing clearer intent and better readability.

Module resolution mirrors Python's rules with support for relative paths and package layouts; Jac detects \texttt{.jac} vs Python modules automatically. The import system respects \texttt{PYTHONPATH}, virtual environments, and package installations, ensuring that your dependency management tools and workflows continue to function normally. Whether you use pip, poetry, conda, or custom package management, Jac code has access to the same packages as Python code in the same environment.

\subsection{Jac as a Python Library}

One of Jac's most powerful features is that its runtime semantics are accessible from pure Python. This means you can adopt Jac's architectural patterns and abstractions without changing your file extensions or build processes. This capability proves invaluable for teams that want to experiment with Jac's concepts or need to maintain compatibility with tools that don't yet support \texttt{.jac} files.

You can use Jac's runtime primitives from pure Python—no Jac syntax required. Define archetypes by subclassing Jac's base classes and annotate abilities with decorators provided by the API. This approach gives you access to Jac's semantic model while writing what looks like idiomatic Python code:

\begin{lstlisting}[language=Python]
from jaclang import JacMachineInterface as _
from jaclang.runtimelib.archetype import NodeArchetype, WalkerArchetype

class Person(NodeArchetype):
    name: str

class Greeter(WalkerArchetype):
    @_.entry
    def start(self, n: Person):
        print(f"Hello, {n.name}!")

if __name__ == "__main__":
    alice = Person(name="Alice")
    walker = Greeter()
    _.spawn(walker, alice)
\end{lstlisting}

This example demonstrates several key concepts. The \texttt{NodeArchetype} and \texttt{WalkerArchetype} base classes provide the foundation for Jac's object-spatial programming model. The \texttt{@\_.entry} decorator marks methods that execute when a walker enters a node. The \texttt{\_.spawn} function initiates a walker's traversal from a specific node. These primitives compose naturally, allowing you to build complex graph-based architectures using familiar Python syntax.

Highlights:
\begin{itemize}
    \item Subclass \texttt{NodeArchetype}, \texttt{EdgeArchetype}, and \texttt{WalkerArchetype} to model graphs and behaviors.
    \item Use \texttt{@\_.entry} and \texttt{@\_.exit} to declare abilities; utilities like \texttt{\_.connect}, \texttt{\_.spawn}, \texttt{\_.report}, and \texttt{\_.printgraph} are available.
    \item Mix this with programmatic imports to load Jac modules and interact with them from Python.
\end{itemize}

This library approach enables gradual adoption strategies. You might start by using Jac's archetypes in a single module, then expand to more modules as your team becomes comfortable with the concepts. You can even mix styles within a single module—using Jac's runtime for architectural components while keeping business logic in traditional Python classes.

\subsection{Inlining Python code inside Jac code}

Sometimes you need to drop down to raw Python within a Jac module. Perhaps you're working with a Python library that uses advanced metaprogramming, or you need to use Python syntax that doesn't have a Jac equivalent yet, or you're gradually migrating Python code to Jac. For these scenarios, Jac provides the \texttt{::py::} directive.

For specialized needs, embed native Python directly within a Jac module using the \texttt{::py::} directive. The enclosed block is treated as Python and shares the module's namespace. This isn't a separate execution context or a foreign function interface—it's Python code that becomes part of the compiled module:

\begin{jacblock}
with entry {
    print("hello ");
}

::py::
def foo():
    print("world")

foo()
::py::
\end{jacblock}

The Python block has full access to the module's namespace. Functions, classes, and variables defined in Jac code are visible to the Python block, and vice versa. This bidirectional visibility enables powerful integration patterns. You can define a class structure in Jac and add method implementations in Python, or define Python helper functions that Jac code calls.

Inline Python is ideal for leveraging Python-only libraries, quick interop, or migrating code incrementally. Symbols defined in a Python block are available to subsequent Jac code in the same module. This feature proves particularly valuable when working with Python libraries that use decorators, context managers, or other Python-specific constructs that might not have direct Jac equivalents. Rather than waiting for Jac to support every Python feature, you can use Python blocks as escape hatches while keeping the majority of your code in Jac's more expressive syntax.

\section{A Well Organized Codebase}

Software architecture isn't just about runtime behavior—it's equally about code organization, maintainability, and team collaboration. Jac recognizes this by providing first-class support for separating interfaces from implementations, enabling codebases that scale both technically and organizationally.

Jac encourages clean separation between interfaces and implementations through its declaration syntax and compiler support. You declare the shape of your module (functions, objects, enums, tests) once, and you may provide the bodies elsewhere. This separation isn't merely a convention—the compiler understands and enforces it, automatically discovering implementation files and ensuring consistency between declarations and implementations.

This is similar in spirit to ``header files'' in languages like C++ or interface definitions in languages like TypeScript, but without manual include wiring or duplicate maintenance burden—the compiler discovers implementation bodies automatically when you follow conventions. The conventions are designed to be intuitive and flexible, supporting both small projects where everything lives in one file and large enterprise codebases with thousands of modules.

\subsection*{Separate interface and implementation}

The declaration syntax is concise and focuses on the what rather than the how:

\begin{jacblock}
can foo() -> str;
obj vehicle;
enum Size;
test check_vehicle;

// implementations can live in the same file or elsewhere
impl foo() -> str { return "Hello"; }
impl vehicle { has name: str = "Car"; }
impl Size { Small=1, Medium=2, Large=3 }
\end{jacblock}

The \texttt{can} keyword declares that a function exists without providing its body. The \texttt{obj} and \texttt{enum} keywords similarly declare types without their full definitions. The \texttt{test} keyword declares test cases that can be implemented separately. This declaration syntax serves multiple purposes: it documents the module's API, enables forward references, and allows parallel development where different team members can work on implementations independently.

\subsection*{Keep implementations beside or under modules}

Jac supports three project layouts that cater to different scales and preferences. Each layout has its strengths, and you can even mix approaches within a single project—using simple layouts for stable modules and more structured layouts for actively developed components.

Three project layouts are common and supported:

\textbf{1) Same file as the declarations}

Simple modules can keep declarations and bodies together for local readability. This approach works well for small utilities, single-purpose modules, and exploratory code where the interface and implementation are tightly coupled.

\textbf{2) Sibling ``.impl.jac'' and ``.test.jac'' files}

\begin{lstlisting}[language=shell]
base/
|- main.jac
|- main.impl.jac
|- main.test.jac
\end{lstlisting}

The compiler automatically discovers these sibling files. No extra imports are required. This layout provides a good balance between organization and simplicity. The main file contains the public interface, the implementation file contains the bodies, and the test file contains test cases. The naming convention makes the relationships clear, and tools can easily identify which files belong together.

\textbf{3) Dedicated ``.impl/'' and ``.test/'' folders}

\begin{lstlisting}[language=shell]
base/
|- main.jac
|- main.impl/
|  |- foo.impl.jac
|  |- vehicle.impl.jac
|  |- size.impl.jac
|- main.test/
   |- check_vehicle.test.jac
\end{lstlisting}

This layout scales well for large codebases where modules have many implementations or where different team members own different components. You can even place all implementations across the project under a single top-level directory (for example, \texttt{src/impl/}) while keeping your public interfaces minimal and readable. This extreme separation works well for projects where the interface stability is paramount and implementation details change frequently.

\subsection*{Why this matters}

The benefits of this organizational approach compound over time and team size:

\begin{itemize}
    \item \textbf{Interface clarity}: Readers see what a module exposes without implementation noise.
    \item \textbf{Team velocity}: Different contributors can implement features without touching interface files.
    \item \textbf{Test hygiene}: Tests live beside modules but away from interfaces.
    \item \textbf{Refactoring safety}: Changing implementations rarely changes consumer-facing interfaces.
\end{itemize}

Interface clarity is particularly valuable for large teams. When you're trying to understand how to use a module, you can read its interface file without being distracted by implementation details. The interface file becomes living documentation that's guaranteed to be accurate because the compiler verifies that implementations match declarations.

Team velocity improves because developers can work in parallel without merge conflicts. One developer can design the interface while another implements it. A third developer can write tests against the interface before the implementation is complete. This parallelization is especially valuable in microservice architectures or when building libraries with stable APIs.

Test hygiene benefits from having a designated place for tests that's separate from both interfaces and implementations. Tests can be comprehensive without cluttering the main codebase, and test utilities can be shared within test directories without leaking into production code.

Refactoring safety comes from the compiler's enforcement of the interface-implementation contract. If you change a function signature in the interface, the compiler will flag all implementations that need updating. If you add a new required method to an object, the compiler ensures all implementations provide it. This safety net enables confident refactoring even in large codebases.

\subsection*{A quick checklist}

When organizing a Jac project, follow these guidelines to maximize clarity and maintainability:

\begin{itemize}
    \item Declare public functions, objects, enums, and tests in your \texttt{.jac} module.
    \item Place bodies in \texttt{.impl.jac} siblings or an \texttt{.impl/} folder.
    \item Keep tests in \texttt{.test.jac} files or a \texttt{.test/} folder.
    \item Import Python libraries directly from Jac where helpful; prefer Jac idioms elsewhere.
    \item Emit pure Python when distributing to Python-only consumers.
\end{itemize}

These guidelines are defaults, not rigid rules. Small scripts might keep everything in a single file. Prototype code might mix declarations and implementations freely. The key is choosing the organization that matches your project's needs and your team's workflow. Jac's flexibility means you can start simple and add structure as your project grows, without rewriting existing code.

The ability to emit pure Python deserves special emphasis. When you need to share code with teams that haven't adopted Jac, or when deploying to environments where Jac isn't available, you can compile your Jac modules to standalone Python files. These generated files are readable, maintainable Python code that preserves your program's behavior while removing the Jac dependency. This capability provides an escape hatch that reduces the risk of adopting Jac—you're never locked in.

Through this compilation model, interoperability design, and organizational philosophy, Jac demonstrates that enhancing a language doesn't require abandoning its ecosystem. Instead, Jac shows how a language can evolve to meet new challenges while preserving the foundations that made it successful. For Python developers, this means you can adopt Jac's powerful abstractions without leaving behind your tools, libraries, or hard-won Python expertise.